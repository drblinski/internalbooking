<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Get Plump - CX Availability Dashboard</title>
  
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #f8f9fa;
      min-height: 100vh;
      color: #333;
    }
    
    .dashboard-container {
      max-width: 1600px;
      margin: 0 auto;
      padding: 20px;
    }
    
    .dashboard-header {
      background: #fff;
      border-radius: 12px;
      padding: 24px;
      margin-bottom: 24px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    
    .header-title {
      font-size: 28px;
      font-weight: 700;
      color: #1a1a1a;
      margin-bottom: 16px;
    }
    
    .header-subtitle {
      font-size: 14px;
      color: #666;
      margin-bottom: 24px;
    }
    
    /* View Toggle Tabs */
    .view-toggle {
      display: flex;
      margin-bottom: 24px;
      border-bottom: 2px solid #e5e5e7;
    }
    
    .view-tab {
      padding: 12px 24px;
      cursor: pointer;
      border-bottom: 3px solid transparent;
      font-weight: 600;
      color: #666;
      transition: all 0.2s;
    }
    
    .view-tab:hover {
      color: #007AFF;
      background: #f8f9fa;
    }
    
    .view-tab.active {
      color: #007AFF;
      border-bottom-color: #007AFF;
      background: #f8f9fa;
    }
    
    /* Controls */
    .controls-section {
      display: flex;
      gap: 16px;
      align-items: center;
      flex-wrap: wrap;
      margin-bottom: 24px;
    }
    
    .control-group {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    
    .control-label {
      font-size: 12px;
      font-weight: 600;
      color: #666;
      text-transform: uppercase;
    }
    
    .control-select, .control-input {
      background: #fff;
      border: 2px solid #e5e5e7;
      border-radius: 8px;
      padding: 10px 16px;
      font-size: 14px;
      font-weight: 500;
      min-width: 160px;
      cursor: pointer;
    }
    
    .control-select:hover, .control-input:hover {
      border-color: #007AFF;
    }
    
    .control-select:focus, .control-input:focus {
      outline: none;
      border-color: #007AFF;
      box-shadow: 0 0 0 3px rgba(0,123,255,0.1);
    }
    
    .date-range-buttons {
      display: flex;
      gap: 8px;
    }
    
    .date-range-btn {
      background: #f8f9fa;
      border: 2px solid #e5e5e7;
      border-radius: 6px;
      padding: 8px 12px;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .date-range-btn:hover {
      border-color: #007AFF;
      background: #e8f4f8;
    }
    
    .date-range-btn.active {
      background: #007AFF;
      color: white;
      border-color: #007AFF;
    }
    
    .refresh-btn, .test-btn {
      background: #007AFF;
      color: white;
      border: none;
      border-radius: 8px;
      padding: 10px 16px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .test-btn {
      background: #34c759;
    }
    
    .refresh-btn:hover {
      background: #0056d6;
      transform: translateY(-1px);
    }
    
    .test-btn:hover {
      background: #30a752;
    }
    
    /* Status Bar */
    .status-bar {
      background: #e8f4f8;
      border: 1px solid #90caf9;
      border-radius: 8px;
      padding: 12px 16px;
      margin-bottom: 20px;
      font-size: 14px;
      color: #1565c0;
    }
    
    .status-bar.loading {
      background: #fff3cd;
      border-color: #ffeaa7;
      color: #856404;
    }
    
    .status-bar.error {
      background: #ffebee;
      border-color: #ffcdd2;
      color: #c62828;
    }
    
    /* Availability Table */
    .table-container {
      background: #fff;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      overflow-x: auto;
    }
    
    .availability-table {
      width: 100%;
      border-collapse: collapse;
      min-width: 800px;
    }
    
    .availability-table th {
      background: #f8f9fa;
      padding: 16px 12px;
      text-align: left;
      font-weight: 600;
      font-size: 14px;
      color: #333;
      border-bottom: 2px solid #e5e5e7;
      position: sticky;
      top: 0;
      z-index: 10;
    }
    
    .availability-table th:first-child {
      background: #fff;
      border-right: 2px solid #e5e5e7;
      min-width: 150px;
      max-width: 200px;
    }
    
    .availability-table td {
      padding: 12px;
      border-bottom: 1px solid #f0f0f0;
      vertical-align: top;
      position: relative;
    }
    
    .availability-table td:first-child {
      background: #fafafa;
      border-right: 2px solid #e5e5e7;
      font-weight: 600;
      color: #333;
      position: sticky;
      left: 0;
      z-index: 5;
    }
    
    .availability-table tr:hover td {
      background: #f8f9fa;
    }
    
    .availability-table tr:hover td:first-child {
      background: #e8f4f8;
    }
    
    /* Date Column Headers */
    .date-header {
      text-align: center;
      min-width: 100px;
    }
    
    .date-day {
      font-size: 12px;
      color: #666;
      display: block;
    }
    
    .date-date {
      font-size: 14px;
      font-weight: 700;
      color: #333;
      display: block;
    }
    
    /* Availability Cells */
    .availability-cell {
      min-height: 60px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      min-width: 100px;
    }
    
    .availability-cell.loading {
      color: #666;
      font-style: italic;
    }
    
    .availability-cell.available {
      background: #e8f5e8;
      border-radius: 6px;
      border: 1px solid #c8e6c9;
    }
    
    .availability-cell.no-availability {
      color: #999;
      font-style: italic;
    }
    
    .availability-cell.not-bookable {
      background: #f8f9fa;
      border: 1px solid #e9ecef;
      color: #6c757d;
      font-style: italic;
    }
    
    .availability-cell.not-bookable:hover {
      background: #e9ecef;
    }
    
    .info-icon {
      display: inline-block;
      font-size: 12px;
      cursor: help;
      opacity: 0.7;
      transition: opacity 0.2s;
      margin-top: 2px;
    }
    
    .info-icon:hover {
      opacity: 1;
      transform: scale(1.1);
    }
    
    /* Tooltip styles for info icons */
    .info-icon[title]:hover::after {
      content: attr(title);
      position: absolute;
      background: #333;
      color: white;
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 11px;
      white-space: pre-line;
      z-index: 1000;
      max-width: 200px;
      margin-top: 20px;
      margin-left: -50px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    }
    
    .availability-cell.error {
      background: #ffebee;
      color: #c62828;
      border-radius: 6px;
      border: 1px solid #ffcdd2;
      font-size: 12px;
    }
    
    .earliest-time {
      font-size: 14px;
      font-weight: 600;
      color: #2d5a2d;
      margin-bottom: 4px;
    }
    
    .slot-count {
      font-size: 11px;
      color: #5a7a5a;
      margin-bottom: 6px;
    }
    
    .book-btn {
      background: #34c759;
      color: white;
      border: none;
      border-radius: 4px;
      padding: 4px 8px;
      font-size: 10px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .book-btn:hover {
      background: #30a752;
      transform: translateY(-1px);
    }
    
    .copy-btn {
      background: #007AFF;
      color: white;
      border: none;
      border-radius: 4px;
      padding: 4px 8px;
      font-size: 10px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      margin-left: 4px;
    }
    
    .copy-btn:hover {
      background: #0056d6;
      transform: translateY(-1px);
    }
    
    /* Loading Spinner */
    .spinner {
      display: inline-block;
      width: 16px;
      height: 16px;
      border: 2px solid #f3f3f3;
      border-top: 2px solid #007AFF;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 4px;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    /* Empty States */
    .empty-state {
      text-align: center;
      padding: 60px 20px;
      color: #666;
    }
    
    .empty-state h3 {
      font-size: 20px;
      margin-bottom: 12px;
      color: #333;
    }
    
    .empty-state p {
      margin-bottom: 8px;
      line-height: 1.5;
    }
    
    .empty-state button {
      margin-top: 16px;
      background: #007AFF;
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
    }
    
    /* Mobile Responsiveness */
    @media (max-width: 768px) {
      .dashboard-container {
        padding: 10px;
      }
      
      .controls-section {
        flex-direction: column;
        align-items: stretch;
      }
      
      .control-group {
        width: 100%;
      }
      
      .control-select, .control-input {
        width: 100%;
      }
      
      .date-range-buttons {
        justify-content: center;
      }
      
      .availability-table th,
      .availability-table td {
        padding: 8px 6px;
        font-size: 12px;
      }
      
      .availability-cell {
        min-height: 50px;
        min-width: 80px;
      }
      
      .earliest-time {
        font-size: 12px;
      }
      
      .slot-count {
        font-size: 10px;
      }
      
      .book-btn, .copy-btn {
        padding: 2px 6px;
        font-size: 9px;
      }
    }
  </style>
</head>
<body>
  <div class="dashboard-container">
    <div class="dashboard-header">
      <h1 class="header-title">Get Plump - CX Availability Dashboard</h1>
      <p class="header-subtitle">Real-time booking availability across all locations and injectors. Toggle between views and filter by date range to help customers find the perfect appointment slot.</p>
      
      <!-- View Toggle Tabs -->
      <div class="view-toggle">
        <div class="view-tab active" data-view="location">📍 Location View</div>
        <div class="view-tab" data-view="injector">💉 Injector View</div>
      </div>
      
      <!-- Controls Section -->
      <div class="controls-section">
        <!-- Primary Filter (Location or Injector based on view) -->
        <div class="control-group">
          <label class="control-label" id="primary-filter-label">Location</label>
          <select class="control-select" id="primary-filter">
            <option value="">Loading...</option>
          </select>
        </div>
        
        <!-- Service Filter -->
        <!-- <div class="control-group">
          <label class="control-label">Service</label>
          <select class="control-select" id="service-filter">
            <option value="all">All Services</option>
            <option value="injectables">Injectables Only</option>
          </select>
        </div> -->
        
        <!-- Date Range -->
        <div class="control-group">
          <label class="control-label">Date Range</label>
          <div class="date-range-buttons">
            <button class="date-range-btn" data-days="7">7 Days</button>
            <button class="date-range-btn active" data-days="14">14 Days</button>
            <button class="date-range-btn" data-days="28">28 Days</button>
          </div>
        </div>
        
        <!-- Action Buttons -->
        <div class="control-group">
          <label class="control-label">Actions</label>
          <div style="display: flex; gap: 8px;">
            <button class="refresh-btn" id="refresh-btn">🔄 Refresh</button>
            <button class="test-btn" id="test-btn">🧪 Test API</button>
          </div>
        </div>
      </div>
      
      <!-- Status Bar -->
      <div class="status-bar" id="status-bar">
        Ready to load availability data. Select filters and click refresh to begin.
      </div>
    </div>
    
    <!-- Table Container -->
    <div class="table-container">
      <div id="table-content">
        <div class="empty-state">
          <h3>Welcome to the CX Availability Dashboard</h3>
          <p>Select your view mode, filters, and date range above.</p>
          <p>Click "Refresh" to load real-time availability data from Boulevard.</p>
          <button onclick="loadAvailabilityData()">Load Availability Data</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // =============================================================================
    // BOULEVARD CLIENT API CONFIGURATION
    // =============================================================================

    const BOULEVARD_CONFIG = {
      businessId: 'f6a06736-1132-4365-b79a-a69c648a746a',
      apiKey: '93ca3f15-6f0e-491d-840b-681a0fef80ed',
      endpoint: 'https://dashboard.boulevard.io/api/2020-01/f6a06736-1132-4365-b79a-a69c648a746a/client'
    };

    // =============================================================================
    // GLOBAL STATE MANAGEMENT
    // =============================================================================

    let globalState = {
      currentView: 'location', // 'location' or 'injector'
      selectedDateRange: 14,   // days
      locations: [],
      injectors: [],
      services: [],
      locationCarts: new Map(), // locationId -> cartId
      availabilityCache: new Map(), // key -> availability data
      isLoading: false
    };

    // Rate limiting queue
    let apiQueue = [];
    let isProcessingQueue = false;
    const MAX_CONCURRENT_CALLS = 2;
    const API_DELAY_MS = 100;

    // =============================================================================
    // BOULEVARD CLIENT API HELPER WITH RATE LIMITING
    // =============================================================================

    /**
     * Core API request function with authentication and error handling
     */
    function makeBoulevardRequest(query, variables = {}) {
      console.log('🔥 Making Boulevard Client API request...');
      console.log('Query type:', query.includes('mutation') ? 'Mutation' : 'Query');
      console.log('Variables:', variables);
      
      return fetch(BOULEVARD_CONFIG.endpoint, {
        method: 'POST',
        headers: {
          'Authorization': 'Basic ' + btoa(BOULEVARD_CONFIG.apiKey + ':'),
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        },
        body: JSON.stringify({
          query: query,
          variables: variables
        })
      })
      .then(response => {
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        return response.json();
      })
      .then(data => {
        if (data.errors && data.errors.length > 0) {
          console.error('GraphQL errors:', data.errors);
          throw new Error(data.errors[0].message);
        }
        console.log('✅ API request successful');
        return data.data;
      });
    }

    /**
     * Queue API calls to respect rate limits - critical for bulk operations
     */
    async function queueApiCall(apiFunction, priority = false) {
      return new Promise((resolve, reject) => {
        const call = { apiFunction, resolve, reject };
        
        if (priority) {
          apiQueue.unshift(call); // Add to front for priority calls
        } else {
          apiQueue.push(call);
        }
        
        processApiQueue();
      });
    }

    /**
     * Process API queue with rate limiting - prevents 429 errors
     */
    async function processApiQueue() {
      if (isProcessingQueue) return;
      
      isProcessingQueue = true;
      
      while (apiQueue.length > 0) {
        // Process up to MAX_CONCURRENT_CALLS at once
        const batch = apiQueue.splice(0, MAX_CONCURRENT_CALLS);
        
        await Promise.all(
          batch.map(async ({ apiFunction, resolve, reject }) => {
            try {
              const result = await apiFunction();
              resolve(result);
            } catch (error) {
              console.error('API call failed:', error);
              reject(error);
            }
          })
        );
        
        // Delay between batches to respect rate limits
        if (apiQueue.length > 0) {
          await new Promise(r => setTimeout(r, API_DELAY_MS));
        }
      }
      
      isProcessingQueue = false;
    }

    // =============================================================================
    // INITIAL DATA LOADING - LOCATIONS, SERVICES, AND INJECTORS
    // =============================================================================

    /**
     * STEP 1: Load all business locations (runs once on dashboard init)
     */
    const BUSINESS_LOCATIONS_QUERY = `
      query GetBusinessLocations {
        business {
          locations(first: 20) {
            edges {
              node {
                id
                name
                tz
                address {
                  line1
                  line2
                  city
                  state
                  zip
                }
              }
            }
          }
        }
      }
    `;

    async function fetchBusinessLocations() {
      console.log('🏢 INITIAL LOAD: Fetching business locations...');
      
      const data = await makeBoulevardRequest(BUSINESS_LOCATIONS_QUERY);
      
      if (!data.business?.locations?.edges) {
        throw new Error('No locations found');
      }
      
      const locations = data.business.locations.edges.map(edge => edge.node);
      console.log(`✅ Found ${locations.length} locations:`, locations.map(l => l.name));
      
      return locations;
    }

    /**
     * STEP 2: Create cart for location and get available services (runs for each location)
     */
    const CREATE_CART_QUERY = `
      mutation CreateCart($locationId: ID!) {
        createCart(input: { locationId: $locationId }) {
          cart {
            id
            availableCategories {
              name
              availableItems {
                id
                name
                description
                ... on CartAvailableBookableItem {
                  listPrice
                  listDuration
                }
              }
            }
          }
        }
      }
    `;

    async function createCartAndGetServices(locationId) {
      console.log(`🛒 Creating cart for location ${locationId}...`);
      
      const data = await makeBoulevardRequest(CREATE_CART_QUERY, { locationId });
      
      if (!data.createCart?.cart) {
        throw new Error(`Failed to create cart for location ${locationId}`);
      }
      
      const cart = data.createCart.cart;
      
      // Cache cart ID for this location
      globalState.locationCarts.set(locationId, cart.id);
      
      // Extract all services from categories
      const services = [];
      if (cart.availableCategories) {
        cart.availableCategories.forEach(category => {
          if (category.availableItems) {
            category.availableItems.forEach(item => {
              services.push({
                ...item,
                categoryName: category.name,
                locationId: locationId
              });
            });
          }
        });
      }
      
      console.log(`✅ Cart ${cart.id} created with ${services.length} services`);
      return { cartId: cart.id, services };
    }

    /**
     * STEP 3: Get staff variants for all services to build injector list
     */
    const GET_STAFF_VARIANTS_QUERY = `
      query GetStaffVariants($cartId: ID!, $itemId: ID!) {
        cart(id: $cartId) {
          id
          availableItem(id: $itemId) {
            id
            name
            ... on CartAvailableBookableItem {
              staffVariants {
                id
                price
                duration
                staff {
                  id
                  firstName
                  lastName
                  bio
                }
              }
            }
          }
        }
      }
    `;

    async function getStaffVariantsForService(cartId, serviceId) {
      console.log(`👥 Getting staff variants for service ${serviceId}...`);
      
      const data = await makeBoulevardRequest(GET_STAFF_VARIANTS_QUERY, { 
        cartId, 
        itemId: serviceId 
      });
      
      if (!data.cart?.availableItem?.staffVariants) {
        return [];
      }
      
      const staffVariants = data.cart.availableItem.staffVariants;
      console.log(`✅ Found ${staffVariants.length} staff variants`);
      
      return staffVariants.map(variant => ({
        ...variant,
        serviceId: serviceId,
        cartId: cartId
      }));
    }

    /**
     * MASTER INITIALIZATION: Load all locations, services, and injectors
     */
    async function initializeDashboardData() {
      console.log('🚀 DASHBOARD INIT: Loading all locations, services, and injectors...');
      updateStatus('Loading locations and services...', 'loading');
      
      try {
        // Step 1: Load all locations
        const locations = await fetchBusinessLocations();
        globalState.locations = locations;
        populateLocationFilter();
        
        // Step 2: Create carts and load services for each location
        const allServices = [];
        const allInjectors = new Map(); // Use Map to deduplicate by staff ID
        
        for (const location of locations) {
          updateStatus(`Loading services for ${location.name}...`, 'loading');
          
          const { services } = await createCartAndGetServices(location.id);
          allServices.push(...services);
          
          // Step 3: Get staff variants for each service
          for (const service of services) {
            updateStatus(`Loading staff for ${service.name} at ${location.name}...`, 'loading');
            
            const staffVariants = await getStaffVariantsForService(
              globalState.locationCarts.get(location.id), 
              service.id
            );
            
            // Add staff to global injectors list
            staffVariants.forEach(variant => {
              if (variant.staff) {
                const staffKey = variant.staff.id;
                const staffName = `${variant.staff.firstName} ${variant.staff.lastName}`;
                
                if (!allInjectors.has(staffKey)) {
                  allInjectors.set(staffKey, {
                    id: variant.staff.id,
                    name: staffName,
                    firstName: variant.staff.firstName,
                    lastName: variant.staff.lastName,
                    bio: variant.staff.bio,
                    locations: [location.name],
                    services: [service.name],
                    variants: [variant]
                  });
                } else {
                  const existingStaff = allInjectors.get(staffKey);
                  if (!existingStaff.locations.includes(location.name)) {
                    existingStaff.locations.push(location.name);
                  }
                  if (!existingStaff.services.includes(service.name)) {
                    existingStaff.services.push(service.name);
                  }
                  existingStaff.variants.push(variant);
                }
              }
            });
          }
        }
        
        globalState.services = allServices;
        globalState.injectors = Array.from(allInjectors.values());
        
        populateInjectorFilter();
        populateServiceFilter();
        
        updateStatus(`✅ Loaded ${locations.length} locations, ${globalState.injectors.length} injectors, ${allServices.length} services`, 'success');
        
        console.log('✅ Dashboard initialization complete');
        console.log(`📊 Data summary: ${locations.length} locations, ${globalState.injectors.length} injectors, ${allServices.length} total services`);
        
      } catch (error) {
        console.error('❌ Dashboard initialization failed:', error);
        updateStatus(`❌ Initialization failed: ${error.message}`, 'error');
        throw error;
      }
    }

    // =============================================================================
    // AVAILABILITY DATA LOADING - THE MAIN TABLE POPULATION
    // =============================================================================

    /**
     * Add service to cart before checking availability (required by Boulevard API)
     */
    const ADD_SERVICE_TO_CART_QUERY = `
      mutation AddServiceToCart($cartId: ID!, $itemId: ID!, $staffVariantId: ID!) {
        addCartSelectedBookableItem(input: {
          id: $cartId,
          itemId: $itemId,
          itemStaffVariantId: $staffVariantId
        }) {
          cart { 
            id 
          }
        }
      }
    `;

    async function addServiceToCart(cartId, serviceId, staffVariantId) {
      const data = await makeBoulevardRequest(ADD_SERVICE_TO_CART_QUERY, {
        cartId,
        itemId: serviceId,
        itemStaffVariantId: staffVariantId
      });
      
      if (!data.addCartSelectedBookableItem?.cart) {
        throw new Error('Failed to add service to cart');
      }
      
      return true;
    }

    /**
     * Get available times for a specific date/staff/service combination
     */
    const GET_AVAILABLE_TIMES_QUERY = `
      query GetAvailableTimes($cartId: ID!, $searchDate: String!, $tz: String!) {
        cartBookableTimes(
          id: $cartId,
          searchDate: $searchDate,
          tz: $tz
        ) {
          id
          score
          startTime
        }
      }
    `;

    async function getAvailableTimesForDate(cartId, date, timezone) {
      const data = await makeBoulevardRequest(GET_AVAILABLE_TIMES_QUERY, {
        cartId,
        searchDate: date,
        tz: timezone
      });
      
      const availableTimes = data.cartBookableTimes || [];
      return availableTimes;
    }

    /**
     * CRITICAL FUNCTION: Get availability for a specific combination
     * This is called for each cell in the table and must be rate-limited
     */
    async function getAvailabilityForCell(locationId, injectorId, date, serviceFilter = 'all') {
      const cacheKey = `${locationId}-${injectorId}-${date}-${serviceFilter}`;
      
      // Check cache first
      if (globalState.availabilityCache.has(cacheKey)) {
        return globalState.availabilityCache.get(cacheKey);
      }
      
      return queueApiCall(async () => {
        try {
          const location = globalState.locations.find(l => l.id === locationId);
          const injector = globalState.injectors.find(i => i.id === injectorId);
          
          if (!location || !injector) {
            throw new Error('Location or injector not found');
          }
          
          // Find a suitable service/variant for this injector at this location
          const suitableVariant = injector.variants.find(variant => {
            const service = globalState.services.find(s => s.id === variant.serviceId && s.locationId === locationId);
            if (!service) return false;
            
            // Apply service filter
            if (serviceFilter === 'injectables' && !service.name.toLowerCase().includes('inject')) {
              return false;
            }
            
            return true;
          });
          
          if (!suitableVariant) {
            const result = { available: false, reason: 'No suitable service found' };
            globalState.availabilityCache.set(cacheKey, result);
            return result;
          }
          
          // Get cart for this location
          const cartId = globalState.locationCarts.get(locationId);
          if (!cartId) {
            throw new Error('No cart found for location');
          }
          
          // Add service to cart
          await addServiceToCart(cartId, suitableVariant.serviceId, suitableVariant.id);
          
          // Get available times
          const availableTimes = await getAvailableTimesForDate(cartId, date, location.tz);
          
          const result = {
            available: availableTimes.length > 0,
            earliestTime: availableTimes.length > 0 ? availableTimes[0].startTime : null,
            totalSlots: availableTimes.length,
            allTimes: availableTimes,
            location: location,
            injector: injector,
            service: globalState.services.find(s => s.id === suitableVariant.serviceId)
          };
          
          // Cache the result
          globalState.availabilityCache.set(cacheKey, result);
          
          return result;
          
        } catch (error) {
          console.error(`Failed to get availability for ${cacheKey}:`, error);
          const result = { available: false, error: error.message };
          globalState.availabilityCache.set(cacheKey, result);
          return result;
        }
      });
    }

    // =============================================================================
    // TABLE RENDERING AND UI MANAGEMENT
    // =============================================================================

    /**
     * Generate date range for table columns
     */
    function generateDateRange(days) {
      const dates = [];
      const today = new Date();
      
      for (let i = 0; i < days; i++) {
        const date = new Date(today);
        date.setDate(today.getDate() + i);
        dates.push(date);
      }
      
      return dates;
    }

    /**
     * Format date for display in table headers
     */
    function formatDateHeader(date) {
      const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
      const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
      
      return {
        day: dayNames[date.getDay()],
        date: `${monthNames[date.getMonth()]} ${date.getDate()}`
      };
    }

    /**
     * Format time for display in cells
     */
    function formatTimeDisplay(timeString) {
      if (!timeString) return '';
      
      try {
        const date = new Date(`2000-01-01T${timeString}`);
        return date.toLocaleTimeString('en-US', {
          hour: 'numeric',
          minute: '2-digit',
          hour12: true
        });
      } catch (error) {
        return timeString;
      }
    }

    /**
     * Create the availability table structure
     */
    function createAvailabilityTable() {
      const dateRange = generateDateRange(globalState.selectedDateRange);
      const currentView = globalState.currentView;
      
      // Determine table structure based on view
      let rows = [];
      if (currentView === 'location') {
        // Show injectors as rows
        const selectedLocation = document.getElementById('primary-filter').value;
        if (selectedLocation) {
          rows = globalState.injectors.filter(injector => 
            injector.locations.includes(globalState.locations.find(l => l.id === selectedLocation)?.name)
          );
        }
      } else {
        // Show locations as rows
        const selectedInjector = document.getElementById('primary-filter').value;
        if (selectedInjector) {
          const injector = globalState.injectors.find(i => i.id === selectedInjector);
          if (injector) {
            rows = globalState.locations.filter(location => 
              injector.locations.includes(location.name)
            );
          }
        }
      }
      
      if (rows.length === 0) {
        return '<div class="empty-state"><h3>No Data Selected</h3><p>Please select a location or injector to view availability.</p></div>';
      }
      
      // Build table HTML
      let tableHTML = '<table class="availability-table"><thead><tr>';
      
      // First column header
      tableHTML += `<th>${currentView === 'location' ? 'Injector' : 'Location'}</th>`;
      
      // Date column headers
      dateRange.forEach(date => {
        const formatted = formatDateHeader(date);
        tableHTML += `<th class="date-header">
          <span class="date-day">${formatted.day}</span>
          <span class="date-date">${formatted.date}</span>
        </th>`;
      });
      
      tableHTML += '</tr></thead><tbody>';
      
      // Table rows
      rows.forEach(row => {
        const rowName = currentView === 'location' ? row.name : row.name;
        tableHTML += `<tr><td>${rowName}</td>`;
        
        // Date cells
        dateRange.forEach(date => {
          const dateStr = date.toISOString().split('T')[0];
          const cellId = currentView === 'location' 
            ? `cell-${document.getElementById('primary-filter').value}-${row.id}-${dateStr}`
            : `cell-${row.id}-${document.getElementById('primary-filter').value}-${dateStr}`;
          
          tableHTML += `<td><div class="availability-cell loading" id="${cellId}">
            <div class="spinner"></div>
            <div style="font-size: 11px; margin-top: 4px;">Loading...</div>
          </div></td>`;
        });
        
        tableHTML += '</tr>';
      });
      
      tableHTML += '</tbody></table>';
      
      return tableHTML;
    }

    /**
     * MAIN FUNCTION: Load and display availability data with progressive loading
     */
    async function loadAvailabilityData() {
      if (globalState.isLoading) {
        console.log('Already loading, skipping...');
        return;
      }
      
      globalState.isLoading = true;
      
      try {
        updateStatus('Building availability table...', 'loading');
        
        // Create table structure
        const tableHTML = createAvailabilityTable();
        document.getElementById('table-content').innerHTML = tableHTML;
        
        if (tableHTML.includes('empty-state')) {
          globalState.isLoading = false;
          return;
        }
        
        // Get parameters
        const currentView = globalState.currentView;
        const dateRange = generateDateRange(globalState.selectedDateRange);
        const serviceFilter = 'all'; // Default to all services since filter is removed
        const selectedPrimary = document.getElementById('primary-filter').value;
        
        if (!selectedPrimary) {
          updateStatus('Please select a location or injector', 'error');
          globalState.isLoading = false;
          return;
        }
        
        // Determine what data to load
        let cellsToLoad = [];
        
        if (currentView === 'location') {
          // Location view: selected location, all relevant injectors, all dates
          const selectedLocation = globalState.locations.find(l => l.id === selectedPrimary);
          const relevantInjectors = globalState.injectors.filter(injector => 
            injector.locations.includes(selectedLocation.name)
          );
          
          dateRange.forEach(date => {
            const dateStr = date.toISOString().split('T')[0];
            relevantInjectors.forEach(injector => {
              cellsToLoad.push({
                locationId: selectedPrimary,
                injectorId: injector.id,
                date: dateStr,
                cellId: `cell-${selectedPrimary}-${injector.id}-${dateStr}`
              });
            });
          });
        } else {
          // Injector view: selected injector, all their locations, all dates
          const selectedInjector = globalState.injectors.find(i => i.id === selectedPrimary);
          const relevantLocations = globalState.locations.filter(location => 
            selectedInjector.locations.includes(location.name)
          );
          
          dateRange.forEach(date => {
            const dateStr = date.toISOString().split('T')[0];
            relevantLocations.forEach(location => {
              cellsToLoad.push({
                locationId: location.id,
                injectorId: selectedPrimary,
                date: dateStr,
                cellId: `cell-${location.id}-${selectedPrimary}-${dateStr}`
              });
            });
          });
        }
        
        updateStatus(`Loading availability for ${cellsToLoad.length} time slots...`, 'loading');
        
        // Load each cell progressively
        let loadedCount = 0;
        const totalCount = cellsToLoad.length;
        
        // Start loading all cells (they'll be queued and rate-limited automatically)
        const loadPromises = cellsToLoad.map(async (cellData) => {
          try {
            const availability = await getAvailabilityForCell(
              cellData.locationId, 
              cellData.injectorId, 
              cellData.date, 
              serviceFilter
            );
            
            // Update the cell UI
            updateCellDisplay(cellData.cellId, availability);
            
            loadedCount++;
            updateStatus(`Loaded ${loadedCount}/${totalCount} slots...`, 'loading');
            
          } catch (error) {
            console.error(`Failed to load cell ${cellData.cellId}:`, error);
            updateCellDisplay(cellData.cellId, { available: false, error: error.message });
            loadedCount++;
          }
        });
        
        // Wait for all cells to load
        await Promise.all(loadPromises);
        
        updateStatus(`✅ Loaded availability for ${totalCount} time slots`, 'success');
        
      } catch (error) {
        console.error('Failed to load availability data:', error);
        updateStatus(`❌ Failed to load availability: ${error.message}`, 'error');
      } finally {
        globalState.isLoading = false;
      }
    }

    /**
     * Update individual cell display with availability data and informative messages
     */
    function updateCellDisplay(cellId, availability) {
      const cellElement = document.getElementById(cellId);
      if (!cellElement) {
        console.warn(`Cell element not found: ${cellId}`);
        return;
      }
      
      cellElement.className = 'availability-cell';
      
      // Create tooltip content for info icon
      let tooltipContent = '';
      if (availability.availableServices && availability.availableServices.length > 0) {
        tooltipContent = `Available services at this location:\n• ${availability.availableServices.join('\n• ')}`;
      }
      
      if (availability.notBookable) {
        // Different messages based on the specific reason
        let displayMessage = availability.message || 'Not Available';
        let detailMessage = '';
        let showInfoIcon = false;
        
        switch (availability.reason) {
          case 'not-bookable-location':
            displayMessage = 'Not Bookable at this Location';
            detailMessage = 'No services available';
            break;
          case 'no-matching-service':
            displayMessage = 'No Matching Service';
            detailMessage = 'See available services';
            showInfoIcon = true;
            break;
          case 'no-injector-data':
            displayMessage = 'Injector Not Found';
            detailMessage = 'Data error';
            break;
          default:
            displayMessage = availability.message || 'Not Available';
            detailMessage = 'See details';
            if (availability.availableServices && availability.availableServices.length > 0) {
              showInfoIcon = true;
            }
        }
        
        cellElement.className += ' not-bookable';
        cellElement.innerHTML = `
          <div style="font-size: 11px; color: #666; font-weight: 600; margin-bottom: 2px;">${displayMessage}</div>
          <div style="font-size: 9px; color: #999; margin-bottom: 4px;">${detailMessage}</div>
          ${showInfoIcon ? `<div class="info-icon" title="${tooltipContent}">ℹ️</div>` : ''}
        `;
      } else if (availability.error) {
        // Show actual errors (API failures, etc.)
        cellElement.className += ' error';
        cellElement.innerHTML = `
          <div style="font-size: 10px; color: #c62828; font-weight: 600;">Error</div>
          <div style="font-size: 9px; color: #999;" title="${availability.error}">${availability.error.substring(0, 15)}...</div>
        `;
      } else if (availability.available) {
        // Show available times with booking options
        cellElement.className += ' available';
        const formattedTime = formatTimeDisplay(availability.earliestTime);
        cellElement.innerHTML = `
          <div class="earliest-time">${formattedTime}</div>
          <div class="slot-count">${availability.totalSlots} slot${availability.totalSlots > 1 ? 's' : ''}</div>
          <button class="book-btn" onclick="handleBooking('${cellId}')">Book</button>
          <button class="copy-btn" onclick="copySlotInfo('${cellId}')">Copy</button>
        `;
      } else {
        // Show no availability but service exists
        cellElement.className += ' no-availability';
        const showInfoIcon = availability.availableServices && availability.availableServices.length > 0;
        cellElement.innerHTML = `
          <div style="font-size: 11px; color: #666; font-weight: 600; margin-bottom: 2px;">No Slots</div>
          <div style="font-size: 9px; color: #999; margin-bottom: 4px;">Try another date</div>
          ${showInfoIcon ? `<div class="info-icon" title="${tooltipContent}">ℹ️</div>` : ''}
        `;
      }
    }

    // =============================================================================
    // UI INTERACTION HANDLERS
    // =============================================================================

    /**
     * Handle view toggle (Location View ↔ Injector View)
     */
    function handleViewToggle(newView) {
      if (globalState.currentView === newView) return;
      
      globalState.currentView = newView;
      
      // Update tab appearance
      document.querySelectorAll('.view-tab').forEach(tab => {
        tab.classList.toggle('active', tab.dataset.view === newView);
      });
      
      // Update primary filter label and options
      const primaryFilterLabel = document.getElementById('primary-filter-label');
      const primaryFilter = document.getElementById('primary-filter');
      
      if (newView === 'location') {
        primaryFilterLabel.textContent = 'Location';
        populateLocationFilter();
      } else {
        primaryFilterLabel.textContent = 'Injector';
        populateInjectorFilter();
      }
      
      // Clear table
      document.getElementById('table-content').innerHTML = '<div class="empty-state"><h3>View Changed</h3><p>Click "Refresh" to load availability data for the new view.</p><button onclick="loadAvailabilityData()">Load Availability Data</button></div>';
      
      // Clear availability cache since view context changed
      globalState.availabilityCache.clear();
      
      updateStatus('View changed. Click refresh to load new data.', 'success');
    }

    /**
     * Handle date range selection
     */
    function handleDateRangeChange(days) {
      globalState.selectedDateRange = days;
      
      // Update button appearance
      document.querySelectorAll('.date-range-btn').forEach(btn => {
        btn.classList.toggle('active', parseInt(btn.dataset.days) === days);
      });
      
      // Clear table and cache
      document.getElementById('table-content').innerHTML = '<div class="empty-state"><h3>Date Range Changed</h3><p>Click "Refresh" to load availability data for the new date range.</p><button onclick="loadAvailabilityData()">Load Availability Data</button></div>';
      globalState.availabilityCache.clear();
      
      updateStatus(`Date range changed to ${days} days. Click refresh to reload.`, 'success');
    }

    /**
     * Handle booking action (demo functionality)
     */
    function handleBooking(cellId) {
      // Extract info from cell ID
      const parts = cellId.replace('cell-', '').split('-');
      const date = parts[parts.length - 1];
      
      alert(`🎉 Booking initiated!\n\nCell: ${cellId}\nDate: ${date}\n\nIn a real implementation, this would open Boulevard's booking flow or create a booking link.`);
    }

    /**
     * Copy slot information to clipboard
     */
    function copySlotInfo(cellId) {
      // Extract information and format for clipboard
      const cellElement = document.getElementById(cellId);
      const time = cellElement.querySelector('.earliest-time')?.textContent || 'N/A';
      const slots = cellElement.querySelector('.slot-count')?.textContent || 'N/A';
      
      const parts = cellId.replace('cell-', '').split('-');
      const date = parts[parts.length - 1];
      
      const copyText = `📅 Available Slot\n⏰ Time: ${time}\n📍 Slots: ${slots}\n📆 Date: ${date}\n🔗 Cell ID: ${cellId}`;
      
      navigator.clipboard.writeText(copyText).then(() => {
        // Visual feedback
        const copyBtn = cellElement.querySelector('.copy-btn');
        if (copyBtn) {
          const originalText = copyBtn.textContent;
          copyBtn.textContent = '✓ Copied';
          copyBtn.style.background = '#34c759';
          setTimeout(() => {
            copyBtn.textContent = originalText;
            copyBtn.style.background = '#007AFF';
          }, 1000);
        }
      }).catch(err => {
        console.error('Failed to copy to clipboard:', err);
        alert('Copy failed. Please try again.');
      });
    }

    // =============================================================================
    // FILTER POPULATION FUNCTIONS
    // =============================================================================

    function populateLocationFilter() {
      const primaryFilter = document.getElementById('primary-filter');
      primaryFilter.innerHTML = '<option value="">Select Location</option>';
      
      globalState.locations.forEach(location => {
        const option = document.createElement('option');
        option.value = location.id;
        option.textContent = location.name;
        primaryFilter.appendChild(option);
      });
    }

    function populateInjectorFilter() {
      const primaryFilter = document.getElementById('primary-filter');
      primaryFilter.innerHTML = '<option value="">Select Injector</option>';
      
      globalState.injectors.forEach(injector => {
        const option = document.createElement('option');
        option.value = injector.id;
        option.textContent = `${injector.name} (${injector.locations.join(', ')})`;
        primaryFilter.appendChild(option);
      });
    }

    function populateServiceFilter() {
      // Service filter removed - no longer needed
      // const serviceFilter = document.getElementById('service-filter');
      // Keep the default options for now - could be expanded to show actual services
      // if needed for more granular filtering
    }

    // =============================================================================
    // STATUS AND UTILITY FUNCTIONS
    // =============================================================================

    function updateStatus(message, type = 'info') {
      const statusBar = document.getElementById('status-bar');
      statusBar.textContent = message;
      statusBar.className = `status-bar ${type}`;
    }

    /**
     * Test API connectivity
     */
    async function testBoulevardAPI() {
      console.log('🧪 Testing Boulevard Client API connectivity...');
      updateStatus('Testing API connectivity...', 'loading');
      
      try {
        const locations = await fetchBusinessLocations();
        console.log(`✅ API Test Successful: Found ${locations.length} locations`);
        updateStatus(`✅ API Test Successful: Found ${locations.length} locations`, 'success');
        alert(`API Test Successful!\n\nFound ${locations.length} business locations.\nDashboard is ready to use.`);
      } catch (error) {
        console.error('💥 API Test Failed:', error);
        updateStatus(`❌ API Test Failed: ${error.message}`, 'error');
        alert(`API Test Failed!\n\nError: ${error.message}\n\nPlease check your Boulevard configuration.`);
      }
    }

    // =============================================================================
    // EVENT LISTENERS AND INITIALIZATION
    // =============================================================================

    document.addEventListener('DOMContentLoaded', function() {
      console.log('📱 CX Availability Dashboard starting...');
      
      // Initialize dashboard data
      updateStatus('Initializing dashboard...', 'loading');
      initializeDashboardData().catch(error => {
        console.error('Dashboard initialization failed:', error);
        updateStatus(`❌ Initialization failed: ${error.message}`, 'error');
      });
      
      // View toggle tabs
      document.querySelectorAll('.view-tab').forEach(tab => {
        tab.addEventListener('click', () => {
          handleViewToggle(tab.dataset.view);
        });
      });
      
      // Date range buttons
      document.querySelectorAll('.date-range-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          handleDateRangeChange(parseInt(btn.dataset.days));
        });
      });
      
      // Action buttons
      document.getElementById('refresh-btn').addEventListener('click', loadAvailabilityData);
      document.getElementById('test-btn').addEventListener('click', testBoulevardAPI);
      
      // Primary filter change
      document.getElementById('primary-filter').addEventListener('change', () => {
        // Clear table when filter changes
        document.getElementById('table-content').innerHTML = '<div class="empty-state"><h3>Filter Changed</h3><p>Click "Refresh" to load availability data with new filters.</p><button onclick="loadAvailabilityData()">Load Availability Data</button></div>';
        globalState.availabilityCache.clear();
      });
      
      // Service filter change - REMOVED since service filter is no longer used
      // document.getElementById('service-filter').addEventListener('change', () => {
      //   globalState.availabilityCache.clear();
      //   updateStatus('Service filter changed. Click refresh to reload with new filter.', 'success');
      // });
    });

    // Export functions for debugging and testing
    window.cxDashboard = {
      testAPI: testBoulevardAPI,
      loadAvailabilityData,
      initializeDashboardData,
      globalState,
      makeBoulevardRequest,
      getAvailabilityForCell
    };

    console.log('✅ CX Availability Dashboard loaded');
    console.log('🎯 Dashboard Features:');
    console.log('  - Toggle between Location View and Injector View');
    console.log('  - Progressive table loading with rate limit protection');
    console.log('  - Real-time availability from Boulevard Client API');
    console.log('  - Copy/Book actions for each available slot');
    console.log('🚀 Ready for CX team to use!');
  </script>
</body>
</html>
